Task Decomposition Evaluation Specification

Version: 0.1
Project: TaskForce
Purpose: 提供量化评估复杂任务拆解质量的指标体系，供系统实现与自动化评估使用。

1. Problem Definition

TaskForce 的核心目标是：
将用户输入的复杂任务转换为一棵结构化的任务树（Task Decomposition Tree, TDT），并对该拆解质量进行自动化评估，以便改进和迭代。

任务树抽象如下：

树或 DAG：T = (V, E)

节点：任务或子任务

边：分解关系或依赖关系

叶节点：需执行的原子任务

我们希望给出一套无参考答案情况下仍可计算的指标体系，并允许未来扩展到“有 Gold 标注”的监督评价。

2. Metric Categories

本规范定义七类可量化指标：

Acyclicity — 无环性

Hierarchy Consistency — 层次一致性

Hierarchy Balance — 层次平衡性

Granularity Reasonableness — 粒度合理性

Redundancy — 冗余度

Executability — 可执行性

Stability Across Iterations — 迭代稳定性

最终形成一个主指标：TDQ (Task Decomposition Quality)。

所有指标输出均为 0–1 浮点数。

3. Metric Definitions
3.1 Acyclicity (A)

判断任务依赖图是否存在环。

若存在环，则 A = 0

若无环，则 A = 1

用途：最基础的结构合法性检查。

3.2 Hierarchy Consistency (H)

希望任务树层级递增清晰，不出现跨层级或倒退关系。

对每条边 (u→v)：

要求 depth(v) > depth(u)

定义：

H = number_of_edges_with(depth(v) > depth(u)) / total_edges


若大量边出现跨层跳跃、逆向则该指标下降。

3.3 Hierarchy Balance (B)

不同节点下的子任务数量应相对均衡，而非极度不均。

令每个非叶节点的子节点数为 deg(v)，其方差为 Var_deg。

定义：

B = 1 - min(1, Var_deg / Var_max)


Var_max 可设定为经验上合理的最大方差（例如 4–6）。

3.4 Granularity Reasonableness (G)

叶节点任务的粒度应适中，不可过大或过小。

对每个 leaf 估计 effort e_i（可用 token 数、LLM 估计工时、Story Points）。

理想粒度区间 [L, U]，例如 [1, 8] 小时。

每个 leaf 的粒度得分：

if L <= e_i <= U:
    g_i = 1
else:
    g_i = exp(-α * |e_i - m| / m)   # m = (L + U) / 2


总体：

G = average(g_i over all leaves)

3.5 Redundancy (R)

避免重复任务。

步骤：

为每个任务节点取 embedding h_i

计算两两余弦相似度

若相似度 > τ（如 0.8），认为两者是高重复对

定义：

r = (# highly similar pairs) / (|V| choose 2)
R = 1 - r


越低重复，R 越高。

3.6 Executability (E)

叶子任务是否已经可被独立执行。

方法：LLM-as-a-judge
对每个叶节点输入 LLM：
“是否能凭这句话直观执行该任务并判断完成？”

LLM 给 1–5 分，再归一化到 0–1。

最终：

E = average(executability over leaves)

3.7 Stability Across Iterations (S)

TaskForce 支持反复修正，因此迭代之间的稳定性本身也是质量指标。

设第 k 和第 k+1 轮任务树分别为 T(k) 和 T(k+1)。

步骤：

对节点文本取 embedding

执行最大匹配（或贪心匹配）得到“任务对应对”

对匹配对计算相似度 sim(i,j)

定义：

S(k) = average(sim(i, j) for matched pairs)
S = average(S(k) for all iterations k)

4. Composite Metric: TDQ

在无参考答案 (no Gold) 情况下：

TDQ = wA*A + wH*H + wB*B + wG*G + wR*R + wE*E + wS*S


各 w ≥ 0，∑w = 1

默认建议：

wA = 0.10

wH = 0.15

wB = 0.10

wG = 0.20

wR = 0.10

wE = 0.25

wS = 0.10

权重可根据需要调整。

5. Optional: Supervised Metrics (Gold Decomposition)

如果存在人工标注的理想拆解 (Gold tree)，可增加：

5.1 Coverage/Precision/Recall/F1

将模型生成的叶节点与 Gold 匹配，根据相似度判定 TP。

Precision = TP / |Predicted|
Recall    = TP / |Gold|
F1        = harmonic_mean(Precision, Recall)

5.2 Structure Similarity (Depth Agreement)

对匹配任务对 (i,j)，比较深度差：

L_sim = 1 - average( |depth_G(i) - depth_P(j)| / L_max )


可加入 TDQ。

6. Suggested JSON Schema for Task Tree
{
  "id": "string",
  "title": "string",
  "description": "string",
  "effort_estimate": "number|null",
  "children": [
    { "id": "...", "title": "...", "description": "...", "children": [...] }
  ],
  "priority": "P0|P1|P2|null",
  "dependencies": ["id1", "id2"]
}

7. Suggested Metric API (Language-Agnostic)
computeAcyclicity(tree): number
computeHierarchyConsistency(tree): number
computeHierarchyBalance(tree): number
computeGranularity(tree, config): number
computeRedundancy(tree, embeddingModel): number
computeExecutability(tree, llmJudge): number
computeStability(trees_over_iterations): number

computeTDQ(metrics, weights): number

8. Implementation Notes

建议先实现纯结构指标（A, H, B），然后实现 embedding 指标（R），最后加 LLM-based（E）。

所有指标尽量保持无状态 determinism，便于自动化测试。

稳定性指标 S 应有可配置的迭代窗口，例如仅比较最近 3–5 轮。