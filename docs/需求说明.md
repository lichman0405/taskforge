项目名：TaskForce

目标：
构建一个基于大语言模型（LLM）的工具，用来对“复杂任务”进行结构化拆解，并通过多轮交互与校验，不断修正和优化拆解结果，最终输出一个清晰的、可执行的任务计划（以及后续可扩展到自动执行部分步骤）。

一、核心用户故事（User Story）

作为一个用户，我输入一句或一段复杂目标（例如：“实现一个支持多租户的报表系统，并与现有数据仓库集成”）。

系统使用 LLM 将这个目标拆解为若干层级的子任务（如 EPIC → Feature → Task）。

系统把拆分结果展示给我，我可以：

调整层级结构；

修改/删除/新增子任务；

标记优先级或依赖关系。

我确认拆解后，系统生成：

一个结构化的任务树；

初步排期或执行顺序建议；

对每个任务的简要说明（包括输入、输出和验收标准）。

后续我可以：

选中某个子任务，让系统进一步“再拆解一层”；

让系统对当前拆解进行“合理性检查”和“盲点检查”，给出改进建议；

将任务树导出为 JSON / Markdown 等格式，用于接入其他工具（如项目管理工具、自动化流水线）。

二、核心功能需求（Functional Requirements）

任务输入与上下文管理

用户可以输入自然语言描述的复杂任务。

系统需要保留对话上下文，以便多轮迭代同一个任务。

支持“新建任务会话”和“继续上次任务会话”。

LLM 任务拆解引擎

调用 LLM，将用户输入转化为任务树结构：

每个节点包含：id、title、description、children、priority、dependencies 等字段。

支持多层级拆分（至少 2–3 层）。

支持“对单个子任务进一步拆解”。

拆解结果的反复校验与优化

系统可以对当前任务树执行“合理性检查”，例如：

是否有明显缺失的步骤；

是否存在顺序/依赖冲突；

是否存在粒度过粗或过细的节点。

用户可以点击类似“请检查并优化拆解”的按钮，系统给出修改建议，并生成一个优化后的版本（可与原版本差异对比）。

交互式编辑

前端（或接口层面）允许用户：

编辑节点标题和描述；

增加/删除节点；

调整父子关系；

标记优先级和状态（TODO / IN_PROGRESS / DONE）。

编辑后的任务树可以再次送入 LLM 进行重新校验与调整。

导出与集成

提供至少一个导出格式（如 JSON + Markdown），便于集成到其他工具（如 Jira、Notion、自研系统）。

JSON 格式要规范、稳定，以便后续可以编写适配器。

三、非功能需求（可简化）

代码结构要清晰、可扩展，便于后续增加：

不同的 LLM 模型；

不同的导出目标（比如直接自动生成 issue）。

尽量保持模块化：拆分为 “LLM 调用层” / “任务树数据结构与操作” / “校验规则” / “API 或 CLI 接口”。

四、技术假设（你可以帮我具体选型）

后端偏向使用 TypeScript/Node.js 或 Python（你可以根据实现便利性和生态建议一个）。

前端如需原型，可以用 Vue（或简单的 web 界面）来呈现任务树。

LLM 调用可以先用 OpenAI API 或者本地兼容的接口（请先抽象出一个 LLMClient 接口，方便替换）。

五、第一阶段的目标（MVP）

在第一阶段，我希望先实现：

一个简单的接口（可以是 CLI、简单 Web 页面或 API），允许用户输入复杂任务。

调用 LLM 生成任务树（至少 2 层结构），并以结构化 JSON 返回。

用户能对任务树进行简单编辑（例如在前端中修改标题/描述、添加删除节点），保存到内存或简单的存储。

调用 LLM 对当前任务树进行一次“合理性审核”，并返回改进建议。

支持导出任务树为 JSON 和 Markdown。

六、现在我希望你（Agent）做的事情

请你先不要直接写完整实现代码，而是：
1）给出一个总体架构设计（包括模块划分与主要数据结构）；
2）设计一个合理的项目文件结构；
3）拆分出若干开发迭代（例如：MVP 第一迭代要做什么，第二迭代要做什么）；
4）为第一迭代列出需要实现的具体函数/类，并给出接口定义（TypeScript 类型或 Python 类型标注）。
当你输出完架构和计划后，再根据计划逐步开始写代码，每一步之前都先向我说明你准备改动哪些文件。